name: CI / CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

env:
  IMAGE_NAME: shred-day
  IMAGE_TAG: ${{ github.sha }}

jobs:
#────────────────────── BUILD + TEST ────────────────────────────
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_DB: shred_day_test
          POSTGRES_USER: rails
          POSTGRES_PASSWORD: password
        ports: [5432:5432]
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    #---------------------------------------------------------------
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # 1️⃣ build the *ci* image (build-stage → has gcc/make/headers)
    - name: Build CI image (build stage)
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./server/Dockerfile        # keep this path
        target: build                    # <- the stage that still has tool-chain
        push: false
        load: true                       # import into runner’s docker engine
        tags: ${{ env.IMAGE_NAME }}:ci   # eg. shred-day:ci

    # 2️⃣ build the slim *production* image (default final stage)
    - name: Build production image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./server/Dockerfile
        push: false
        load: true
        tags: ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

    # ── 2️⃣ run RSpec in the *ci* image (=build stage) ───────────────
    - name: RSpec
      uses: addnab/docker-run-action@v3
      with:
        image: shred-day:ci
        options: |
          --user 0
          -e RAILS_ENV
          -e DATABASE_URL
          -e RAILS_MASTER_KEY
        run: |
          cd /rails/server
          printf '%s' "$RAILS_MASTER_KEY" > config/master.key
          chmod 600 config/master.key
          bundle install --with test --quiet
          bundle exec rails db:create db:migrate
          bundle exec rspec
      env:
        RAILS_ENV: test
        DATABASE_URL: postgres://rails:password@postgres:5432/shred_day_test
        RAILS_MASTER_KEY: ${{ secrets.RAILS_MASTER_KEY }}

    # 3️⃣ Start Rails container for Cypress
    - name: Rails Backend for Cypress
      uses: addnab/docker-run-action@v3
      with:
        name: rails-backend-cypress
        image: shred-day:ci
        options: |
          --name rails-backend-cypress
          --user 0
          -e RAILS_ENV
          -e DATABASE_URL
          -e RAILS_MASTER_KEY
          -e PORT
          -p 3000:3000
          --detach
        run: |
          cd /rails/server
          printf '%s' "$RAILS_MASTER_KEY" > config/master.key
          chmod 600 config/master.key
          bundle install --with test --quiet
          bundle exec rails db:seed
          bundle exec rails server -b 0.0.0.0 -p 3000
      env:
        RAILS_ENV: test
        DATABASE_URL: postgres://rails:password@postgres:5432/shred_day_test
        RAILS_MASTER_KEY: ${{ secrets.RAILS_MASTER_KEY }}
        PORT: 3000

    - uses: actions/checkout@v4
    - name: Setup tmate session
      uses: mxschmitt/action-tmate@v3

    # Add a robust wait step that checks a health endpoint (adjust URL if needed)
    - name: Wait for Rails server
      run: |
        echo "Waiting for Rails server at http://localhost:3000..."
        # Use timeout and curl to wait for the server to respond with HTTP 2xx/3xx
        # If no health check endpoint, consider 'until nc -z localhost 3000' as a simpler check
        timeout 60s bash -c ' \
          until curl -s -f -o /dev/null http://localhost:3000/up; do \
            echo "Waiting for Rails (curl)..."; \
            sleep 2; \
          done \
        ' || (echo "Rails server failed to start!" && docker logs rails-backend-cypress && exit 1)
        echo "Rails server is up!"

    # Optional: Check container status before Cypress runs
    - name: Check Rails container status
      run: docker ps --filter name=rails-backend-cypress

    #---------------------------------------------------------------
    # 4️⃣ Run Cypress in its own container against http://localhost:3000
    - name: Cypress
      uses: cypress-io/github-action@v6
      with:
        working-directory: client
      env:
        CYPRESS_baseUrl: http://localhost:3000
        VITE_API_BASE_URL: http://localhost:3000

    # Show Rails logs if anything fails
    - name: Dump Rails log on failure
      if: failure()
      run: docker logs rails-backend-cypress || true

#──────────────────────── DEPLOY ────────────────────────────────
  deploy:
    name: Deploy
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - uses: actions/checkout@v4

    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.3.0'

    - name: Install Kamal
      run: gem install kamal -v $(awk '/kamal \(/ { gsub(/.*\(|\).*/, "", $0); print $0 }' server/Gemfile.lock)

    - name: Setup SSH agent
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Prepare Kamal secrets
      run: |
        mkdir -p .kamal
        {
          echo "KAMAL_REGISTRY_PASSWORD: $KAMAL_REGISTRY_PASSWORD"
          echo "RAILS_MASTER_KEY: $RAILS_MASTER_KEY"
          echo "POSTGRES_PASSWORD: $POSTGRES_PASSWORD"
        } >> .kamal/secrets
      env:
        KAMAL_REGISTRY_PASSWORD: ${{ secrets.KAMAL_REGISTRY_PASSWORD }}
        RAILS_MASTER_KEY:       ${{ secrets.RAILS_MASTER_KEY }}
        POSTGRES_PASSWORD:      ${{ secrets.POSTGRES_PASSWORD }}

    - name: Deploy
      env:
        RAILS_MASTER_KEY:  ${{ secrets.RAILS_MASTER_KEY }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      run: kamal deploy --verbose
